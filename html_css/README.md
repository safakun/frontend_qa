### HTML. Cемантическая верстка. Web Accessibility
- **Cемантическая верстка. Зачем нужна**
- Семантическая вёрстка — подход к разметке, который опирается не на содержание сайта, а на смысловое предназначение каждого блока и логическую структуру документа. Даже в этой статье есть заголовки разных уровней — это помогает читателю выстроить в голове структуру документа. Так и на странице сайта — только читатели будут немного другими. 

- Зрячие пользователи могут без проблем с первого взгляда понять, где какая часть страницы находится — где заголовок, списки или изображения. Для незрячих или частично незрячих всё сложнее. Основной инструмент для просмотра сайтов не браузер, который отрисовывает страницу, а скринридер, который читает текст со страницы вслух.

- Этот инструмент «зачитывает» содержимое страницы, и семантическая структура помогает ему лучше определять, какой сейчас блок, а пользователю понимать, о чём идёт речь. Таким образом семантическая разметка помогает б_о_льшему количеству пользователей работать с вашим сайтом. Например, наличие заголовков помогает незрячим в навигации по странице. У скринридеров есть функция навигации по заголовкам, что ускоряет знакомство с информацией на сайте.

= Чтобы сайт был выше в поисковиках. Поисковики не разглашают правила ранжирования, но известно, что наличие семантической разметки страниц помогает поисковым ботам лучше понимать, что находится на странице, и в зависимости от этого ранжировать сайты в поисковой выдаче. 

- **Доступность (Accessibility**, A11y в англоязычной среде) в веб-разработке — это обеспечение возможности использования сайтов как можно большим числом людей, включая тех, чьи способности как-либо ограничены.

- Технологии облегчают жизнь многим людям. А людям с ограниченными возможностями технологии дают такие возможности, которые ранее им были недоступны. Доступность в контексте разработки подразумевает создание такого контента, пользоваться которым мог бы каждый, несмотря на индивидуальные физические или когнитивные способности и вне зависимости от того, как они получают доступ в сеть.


### CSS. Вес селектора. CSS-архитектура (БЭМ, OOCSS, SMACSS)
- **Вес селектора**
- Все CSS-селекторы имеют свой вес, который определяет как взаимодействуют одинаковые свойства, заданные в разных местах кода одному и тому же элементу.
- Иногда это может создавать трудности, когда свойство, объявленное ниже в коде, перекрывается тем, что объявленно выше, потому что селектор первого более специфичен (имеет больший вес).

- Вот пример проблемы. Есть див с id="container", внутри него некоторый текст и список ссылок.

```html
<div id="container">
  <p><a href="#">link in P</a></p>

  <ul class="list">
    <li><a href="#">Link1</a></li>
    <li><a href="#">Link2</a></li>
  </ul>
</div>
```
- Сначала задаём всем ссылкам внутри #container оранжевый фон:

```css
#container A {
  background: orange;
}
``` 
- А потом, чтобы в списке .list внутри контейнера ссылки имели зелёный фон, ниже дописываем такое:
```css
.list A {
  background: mediumspringgreen;
}
``` 

- Казалось бы, ссылки в тексте должны получить оранжевый фон, а ссылки в списке — зеленый, но нет 

- Почему так? Потому, что первый селектор содержит ID и перевешивает второй, то есть:
```css
#container A > .list A 
```
**Вес селектора**
- Специфичность селектора рассчитывается по 4-м позициям:
```css
#container A
```
1. style=""
2. #id 
3. .class
4. <tag>
```css
#container UL A
```
1. style=""
2. #id 
3. .class
4. <tag>

**Вес селекторов (по убыванию):**
```css
style="" 1,0,0,0

#id 0,1,0,0

.class 0,0,1,0

[attr=value] 0,0,1,0

LI 0,0,0,1

* 0,0,0,0 
``` 

- У стилей, заданных в атрибуте style, на первой позиции будет единица — 1,0,0,0. Это самая высокая специфичность, которая перевешивает свойства, заданные другими способами.

- Переопределить стили, заданные в style, можно дописав !important к значению свойства в таблице стилей.

- Обратный вариант — универсальный селектор *, он не имеет веса: 0,0,0,0. 

- Примеры:
```css
LI 0,0,0,1 — селектор по тегу

UL LI 0,0,0,2 — селектор c двумя тегами весит больше, чем с одним.

.orange 0,0,1,0 — селектор с классом весит больше, чем селектор с тегом.

.orange A SPAN 0,0,1,2 — селектор перевесит предыдущий, потому что помимо класса содержит два тега.

#page .orange 0,1,1,0 — селектор с ID перевесит всё, кроме inline-стилей.

Теперь сравним селекторы из исходного примера:

#container A 0,1,0,1

.list A 0,0,1,1

0,1,0,1 > 0,0,1,1 — хорошо видно, что селектор с ID весит больше, чем селектор с классом, поэтому все ссылки имеют оранжевый фон, хотя ниже в коде им задан зеленый. 
``` 

- Варианты решений

1. Добавить !important

```css
#container A {
  background: orange;
}

.list A {
  background: mediumspringgreen !important;
}
```
- Ссылки получат зеленый фон, быстро и легко. Но это плохой способ, потому что код запутывается ещё больше. Со временем для переопределения !important в одном месте может потребоваться добавить его в других местах. Иерархичность начнет работать не сверху низ и от общего к частному, а как попало. В конце-концов поддерживать такой код будет весьма проблематично.

- В общих случаях использовать !important не рекомендуется, но может пригодиться, если нужно, чтобы часто используемый блок на всех страницах выглядел одинаково, независимо от окружения. В любом случае нужно всегда четко понимать зачем вы его используете.

2. Следующий очевидный способ — добавить #container ко второму селектору, чтобы увеличить его вес:
```css
#container A {
  background: orange;
}

#container .list A {
  background: mediumspringgreen;
}
``` 

- Это тоже сработает, но решение так себе: удлиняется цепочка селекторов (что может отразиться на скорости отрисовки страницы) и ухудшается читаемость кода. Так тоже делать не стоит.

- 1-й и 2-й способ могут использоваться, если у вас нет доступа к разметке, а в ней нет нужных классов. Если же вы можете редактировать разметку либо классы у элементов таки есть — используйте последний способ, самый правильный:

3. **Просто не используйте в стилях селекторы с ID, используйте классы.** 

- Посмотрим на разницу между #container и с .container:
```css
#container A 0,1,0,1 — селектор с ID перевешивает всё вне зависимости от своего расположения в коде.
```
- Заменим в разметке страницы id на class:
```css
.container A0,0,1,1 — селектор с классом весит меньше, он менее специфичен.
```
- Селектор ссылок в списке весит столько же:
```css
.list A 0,0,1,1
```

- Это означает, что при равном весе селекторов применятся стили, объявленные ниже в коде. То есть достаточно будет просто написать стили, следуя от общего к частному, сверху вниз.

В итоге разметка может быть такой:
```css
<div class="container">
  <p><a href="#">link in P</a></p>

  <ul class="list">
    <li><a href="#">Link1</a></li>
    <li><a href="#">Link2</a></li>
  </ul>
</div>
``` 

- А стили — такими:
```css
.container A {
  background: orange;
}

.list A {
  background: mediumspringgreen;
}
```
И код работает так, как ожидается

- Если id в вашей разметке уже используется в Js, логичнее будет добавить элементу класс и перевесить стили на него. Если же id участвует только в разметке — лучше заменить его на class.

- **В качестве общих рекомендаций так же следует упомянуть, что нужно как можно меньше использовать селекторы по тегу и как можно больше — селекторы по классу. Это поможет избежать проблем при повторном использовании блоков сайта, а при использовании "умных" классов — может значительно сократить цепочки селекторов, увеличить читабельность кода и скорость отрисовки страницы.**

- **CSS АРХИТЕКТУРА** 
- Многие девелоперы, даже имея за плечами не один успешно выполненный коммерческий проект не оставляют поиски наилучшего способа организации стилей в макете. И большинство из них остановились на синтезе OOCSS, SMACSS, BEM и SASS. 

- Принцип OOCSS заключается в раздельном существовании объекта и его модификаций. Это нужно для того, чтобы мы могли поместить клон объекта в любое место на сайте без необходимости перебивать существующие стили.

- Клон объекта через новый класс расширяется дополнительными стилями (дизайном). Таким образом, в html документе к одному блоку присваивается сразу несколько классов. Нанизывание классов характерно для многих фреймворков, например Bootstrap. 

- Однако множественность классов идет вразрез с принципами SMACSS, который рекомендует избегать повторений. Это один из главных принципов написания «чистого кода». 

- На помощь приходит SASS, а именно директивы @include и @extend. С их помощью к любому блоку можно присоединять дополнительные стили минуя html.

- С помощью строки
```css
@extend .button;
``` 

- мы расширяем классы blue и red стилями из класса button:.
```html
<h2>SASS  @extend</h2>
<div class="wrapper">
<a href="#" class="blue">Linkedin</a>
<a href="#" class="red">Myspace</a>
</div>
 ```
 ```css
/*SASS @extend - button записывается в CSS*/
 
.button 
  border:2px solid gray;
  padding:5px 15px;
  border-radius:5px;
  color:white;
  font-weight:bold;
.blue 
    @extend .button;
    background:blue;
.red 
    @extend .button;
    background:red;
  ```

  - При компиляции SCSS мы получаем такую запись в CSS:
```css
.button, .blue, .red 
  border:2px solid gray;
  padding:5px 15px;
  border-radius:5px;
  color:white;
  font-weight:bold;
.blue 
    background:blue;
.red 
    background:red;
```

- Это полностью совпадает с принципами OOCSS, которые настоятельно рекомендует соблюдать его создатель Jonathan Snook. НО! Стили для класса button также записываются в CSS. И в данном случае совершенно напрасно, они нам не нужны. Так очень часто бывает в макете, когда базовый дизайн не применяется. 

- В таком случае лучше воспользоваться директивой Placeholder Selectors (%). Placeholder записывается в CSS ТОЛЬКО! когда его вызовут:

```html
@extend %button;
<h2>SASS  %placeholder selector</h2>
<div class="wrapper">
<a href="#" class="yellow">Linkedin</a>
<a href="#" class="pink">Myspace</a>
</div>
``` 

```scss
/*SASS %placeholder selector - %button НЕ записывается в css*/
 
%button 
  border:2px solid gray;
  padding:5px 15px;
  border-radius:5px;
  color:gray;
  font-weight:bold;
.yellow 
    @extend %button;
    background:yellow;
.pink 
    @extend %button;
    background:pink;
``` 

- Однако в таком случае в скомпилированном CSS одни и те же стили будут повторяться в каждом классе. 

```css
.yellow 
  border:2px solid gray;
  padding:5px 15px;
  border-radius:5px;
  color:gray;
  font-weight:bold;
  background:yellow;
.pink 
  border:2px solid gray;
  padding:5px 15px;
  border-radius:5px;
  color:gray;
  font-weight:bold;
  background:pink;
``` 

- То же самое произойдет и в случае использования директивы @mixin Однако при использовании mixin мы получаем определенное преимущество.

- Переменные, определенные в mixin, можно изменить один раз и они изменятся во всем макете сразу. Это экономит массу времени и сил. Кроме того, используя миксин, можно в блоке менять значения переменных, если того требует дизайн (смотрите демо).

```html
<h2>SASS  @mixin</h2>
<div class="wrapper">
<a href="#" class="gray">Linkedin</a>
<a href="#" class="green">Myspace</a>
</div>
```
```scss
/*SASS @mixin. Не записывается в CSS. 
Предназначен для использования переменных 
типа $padding-vertical:15px;*/
 
@mixin button $padding-vertical, $padding-horizontal, $border-radius 
  border:2px solid gray;
  padding: $padding-vertical $padding-horizontal;
  border-radius:$border-radius;
  color:white;
  font-weight:bold;
.gray 
    @include button5px, 15px, 5px;
    background:gray;
.green 
    @include button5px, 15px, 5px;
    background:green;
  ``` 

  - **SASS позволяет избежать лишних классов в макете благодаря вложенности**. Однако иногда вложенность играет с нами злую шутку и к блоку применяется большое наследование, типа 
```css
#header .main-line .state.state-on
```

- И здесь пришло время обратиться к методологии BEM, разработанной компанией Yandex. Она определяет принцип создания имен классов для элементов различного уровня и их состояний. 

- Мы будем рассматривать не оригинальный BEM, а версию Nicolas Gallagher, которой все предпочитают пользоваться, потому, что она намного прозрачнее.

- Вкратце, что она из себя представляет правильный CSS на BEM. 

```css
.block 
.block__element 
.block--modifier

.block — стиль для родительского блока
.block__element — стиль для вложенного дочернего блока.
.block--modifier — стиль состояния блока.
``` 
- Возможны различные версии.

- У дочернего блока может быть стиль состояния:
```css
person__hand--left
```
- Как бы то ни было, **BEM прекрасно решает проблему с наследованием в SASS**. И хотя бы одним этим он может быть нам полезен, чтобы написать правильный CSS.

В SASS мы пишем:

```less
.div 
    color: red;
 
    .colored 
        color: black;
``` 

В скомпилированном CSS получается:
```css
.div {
      color: red;
    }
.div .colored {
    color: black;
    }
``` 
- Наследование очевидно. 

- Sass 3.3+ BEM делает возможным следующую комбинацию:

```less
.div 
    color: red;
 
    &__colored 
        color: black;
``` 

- В скомпилированном CSS получается:

```css
.div {
        color: red;
    }
.div__colored {
        color: black;
    }
``` 

- **Наследованию конец, генерируется только один класс!** 

- **Организация файловой структуры**
- А теперь поговорим об организации файловой структуры макета на SASS. Изучая опыт ведущих зарубежных девелоперов и их макеты, а также используя собственные скромные познания, мною был сделан следующий вывод об оптимальной структуре макета:

```scss
main.scss
``` 

- Чаще всего это style.css, но здесь во мне говорит привычка делать макеты на html5 boilerplate. Основной файл макета, куда импортируются все остальные его части (см. ниже) 

```less
_base.scss
```
- Включает в себя normalize.css и стили для базовых элементов сайта: html, body, a, ul, li и так далее. 

```less
_gride.scss
```
- Если вы пользуетесь собственной сеткой или переопределяете готовые фреймворки. Соответственно сюда импортированы папки _mixins, _variables.scss и пр. 

```less
_layout.scss
```
- Стили для объектов.
```less
_modules.scss
```
- Все модули с комментариями. Модули отделены от объектов, как и рекомендует SMACSS. Некоторые девелоперы рекомендуют собрать все модули в один файл и сделать навигацию по комментариям.

- Мне же больше близок подход SMACSS, где предлагается рассортировать все по папкам. Я предпочитаю сохранить каждый модуль в отдельном файле и затем импортировать в _modules.scss. Так удобнее редактировать. Также считают и создатели SCSS Bootstrap.
```less
_other.scss
```
- Все, что не вошло в обозначенные выше папки.
```less
_shame.scss
```
- Фиксы 

### 